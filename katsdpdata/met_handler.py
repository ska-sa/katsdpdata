import pysolr
import uuid
import os
import urlparse
import time
import mimetypes

class MetaDataHandlerException(Exception):
    """Handle execptions generated by the metadata handler class"""
    pass

class MetaDataHandler(object):
    """Class for generating solr metadata that follows a OODT styled data product.
    
    Parameters
    ----------
    solr_url: string : solr url endpoint for metadata queries.
    product_type: string : A predefined product type for OODT purposes.
    product_name: string : The name of the product.
    product_id: string : Unique identifier for product. If set to none,
                         product will have a self generated uuid.
    """
    def __init__(self, solr_url, product_type, product_name, product_id=None):
        super(MetaDataHandler, self).__init__()
        self.solr_url = solr_url
        self.solr = pysolr.Solr(self.solr_url)
        self.product_type = product_type
        self.product_name = product_name
        if product_id:
            self.product_id = product_id
        else:
            self.product_id = str(uuid.uuid4())

    def create_core_met(self):
        """Create the core OODT style metadata.
        
        Returns
        -------
        met: dict : metadata containing the _version_ for version tracking commits to solr.
        """
        new_met = {}
        new_met['id'] = self.product_id
        new_met['CAS.ProductId'] = self.product_id
        new_met['CAS.ProductName'] = self.product_name
        new_met['CAS.ProductTypeId'] =  'urn:kat:{}'.format(self.product_type)
        new_met['CAS.ProductTypeName'] = self.product_type
        self.solr.add([new_met])
        return self.get_prod_met(self.product_id)  #return with _version_

    def add_ref_original(self, met, original_refs):
        """Handle original references for product and decide if its Flat or Hierarchical.

        Parameters
        ----------
        met: dict : metadata dict, a local copy of the solr doc to update.

        Returns
        -------
        met: dict : metadata containing the _version_ for version tracking commits to solr.
        """
        if len(original_refs) == 0:
            raise MetaDataHandlerException('No product in {}'.format(original_refs))
        elif len(original_refs) == 1:
            met['CAS.ProductStructure'] = 'Flat' 
        else:
            met['CAS.ProductStructure'] = 'Hierarchical'
        product_sizes = [os.path.getsize(p) for p in original_refs]
        product_types = [mimetypes.guess_type(p)[0] 
                         if mimetypes.guess_type(p)[0] else 'application/x-data' 
                         for p in original_refs]
        met['CAS.ReferenceOriginal'] = map(lambda x: urlparse.urlparse('file://'+x).geturl(), original_refs)
        met['CAS.ReferenceFileSize'] = product_sizes
        met['CAS.ReferenceMimeType'] = product_types
        self.solr.add([met])
        return self.get_prod_met(met['id']) #return with updated _version_

    def add_ref_datastore(self, met, datastore_refs):
        """Handle datastore references for product once ingested into the backend storage.

        Parameters
        ----------
        met: dict : metadata dict, a local copy of the solr doc to update.

        Returns
        -------
        met: dict : metadata containing the _version_ for version tracking commits to solr.
        """
        met['CAS.ReferenceDatastore'] = map(lambda x: urlparse.urlparse(x).geturl(), sorted(datastore_refs))
        self.solr.add([met])
        return self.get_prod_met(met['id']) #return with updated _version_

    def set_product_transferring(self, met):
        """Set product transfer status while transfering to the backend storage.

        Parameters
        ----------
        met: dict : metadata dict, a local copy of the solr doc to update.

        Returns
        -------
        met: dict : metadata containing the _version_ for version tracking commits to solr.
        """
        met['CAS.ProductReceivedTime'] = ''
        met['CAS.ProductTransferStatus'] = 'TRANSFERRING'
        self.solr.add([met])
        return self.get_prod_met(met['id'])  #return with updated _version_

    def set_product_received(self, met):
        """Set product transfer status once received into the backend storage.

        Parameters
        ----------
        met: dict : metadata dict, a local copy of the solr doc to update.

        Returns
        -------
        met: dict : metadata containing the _version_ for version tracking commits to solr.
        """
        met['CAS.ProductReceivedTime'] = time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime())
        met['CAS.ProductTransferStatus'] = 'RECEIVED'
        self.solr.add([met])
        return self.get_prod_met(met['id'])  #return with updated _version_

    def add_prod_met(self, met, prod_met):
        """Add the product based metadata to solr.
        
        Returns
        -------
        met: dict : metadata containing the _version_ for version tracking commits to solr.
        """

        #ProductName is mapped internally by OODT. Pop it if we're going to insert directly into SOLR.
        prod_met.pop('ProductName', None) 
        met.update(prod_met)
        while True:
            try:
                self.solr.add([met])
            except pysolr.SolrError:
                sleep(10)
                continue
            break
        return self.get_prod_met(met['id'])

    def get_prod_met(self, prod_id=None):
        """Get the metadata for a product, if prod_id is not specified, use self.prod_id.

        Parameters
        ----------
        prod_id: string : the product id to find. 

        Returns
        -------
        met: dict : metadata containing the _version_ for version tracking commits to solr.
        """
        copy_fields = ['Observer_lowercase']
        if not prod_id:
            prod_id = self.prod_id
        query = 'id:{}'.format(prod_id)
        res = self.solr.search(query)
        if res.hits == 0:
            return None
        elif res.hits > 1:
            raise MetaDataHandlerException('{} returned for {}'.format(res.hits, query))
        #filter out copy field
        doc = res.docs[0]
        for c in copy_fields:
            doc.pop(c, None)
        return doc

    def del_prod_met(self, prod_id):
        """Delete product metadata. Use with caution, as will delete product metadata
        from solr.
 
        Parameters
        ----------
        prod_id: string : the product id to delete.
        """
        met = self.get_prod_met(prod_id) 
        self.solr.delete(id=prod_id)
        return met
