import mimetypes
import os
import pysolr
import time
import uuid

from urllib.parse import urlparse

mimetypes.add_type('application/x-rdb', '.rdb')


class MetaDataHandlerException(Exception):
    """Handle execptions generated by the metadata handler class"""
    pass


class MetaDataHandler(object):
    """Class for generating solr metadata that follows a OODT styled data product.

    Parameters
    ----------
    solr_url: string : solr url endpoint for metadata queries.
    """
    def __init__(self, solr_url):
        super(MetaDataHandler, self).__init__()
        self.solr_url = solr_url
        self._solr = pysolr.Solr(self.solr_url)

    def _solr_add(self, met):
        met.pop('_version_', None)
        self._solr.add([met])

    def _solr_delete(self, prod_id):
        self._solr.delete(id=prod_id)

    def _solr_search(self, query):
        return self._solr.search(query)

    def create_core_met(self, product_type, product_name, product_id=None):
        """Create the core OODT style metadata.

        Parameters
        ----------
        product_type: string : A predefined product type for OODT purposes.
        product_name: string : The name of the product.
        product_id: string : Unique identifier for product. If set to none,
                             product will have a self generated uuid.

        Returns
        -------
        met: dict : metadata containing the _version_ for version tracking commits to solr.
        """
        if product_id:
            product_id = product_id
        else:
            product_id = str(uuid.uuid4())

        new_met = {}
        new_met['id'] = product_id
        new_met['CAS.ProductId'] = product_id
        new_met['CAS.ProductName'] = product_name
        new_met['CAS.ProductTypeId'] = 'urn:kat:{}'.format(product_type)
        new_met['CAS.ProductTypeName'] = product_type
        self._solr_add(new_met)
        return self.get_prod_met(product_id)  #return with _version_

    def add_ref_original(self, product_id, original_refs):
        """Handle original references for product and decide if its Flat or Hierarchical.

        Parameters
        ----------
        product_id: string: unique product id.
        original_refs: list of references to add to the met for the product_id

        Returns
        -------
        met: dict : metadata containing the _version_ for version tracking commits to solr.
        """
        def prod_structure(num_prods):
            return ('Flat', 'Hierarchical')[num_prods > 1]

        def prod_size(ref):
            return (-1, os.path.getsize(urlparse(ref).path))[urlparse(ref).scheme == 'file']

        def mime_type(ref):
            return mimetypes.guess_type(ref)[0]

        met = self.get_prod_met(product_id)

        met['CAS.ProductStructure'] = prod_structure(len(original_refs))
        met['CAS.ReferenceOriginal'] = original_refs
        met['CAS.ReferenceFileSize'] = [prod_size(ref) for ref in original_refs]
        met['CAS.ReferenceMimeType'] = [mime_type(ref) for ref in original_refs]

        self._solr_add(met)
        return self.get_prod_met(met['id']) #return with updated _version_

    def add_ref_datastore(self, product_id, datastore_refs):
        """Handle datastore references for product once ingested into the backend storage.

        Parameters
        ----------
        product_id: string: unique product id.
        datastore_refs: list of references to add to the met for the product_id

        Returns
        -------
        met: dict : metadata containing the _version_ for version tracking commits to solr.
        """
        met = self.get_prod_met(product_id)

        met['CAS.ReferenceDatastore'] = map(lambda x: urlparse(x).geturl(), sorted(datastore_refs))
        self._solr_add(met)
        return self.get_prod_met(met['id']) #return with updated _version_

    def set_product_transferring(self, product_id):
        """Set product transfer status while transfering to the backend storage.

        Parameters
        ----------
        product_id: string: unique product id.

        Returns
        -------
        met: dict : metadata containing the _version_ for version tracking commits to solr.
        """
        met = self.get_prod_met(product_id)
        met['CAS.ProductTransferStatus'] = 'TRANSFERRING'
        self._solr_add(met)
        return self.get_prod_met(met['id'])  #return with updated _version_

    def set_product_received(self, product_id):
        """Set product transfer status once received into the backend storage.

        Parameters
        ----------
        product_id: string: unique product id.

        Returns
        -------
        met: dict : metadata containing the _version_ for version tracking commits to solr.
        """
        met = self.get_prod_met(product_id)
        met['CAS.ProductReceivedTime'] = time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime())
        met['CAS.ProductTransferStatus'] = 'RECEIVED'
        self._solr_add(met)
        return self.get_prod_met(met['id'])  #return with updated _version_

    def set_product_failed(self, product_id):
        """Set product transfer status as failed, to indicate the product transfer failed in
           some way.

        Parameters
        ----------
        product_id: string: unique product id.

        Returns
        -------
        met: dict : metadata containing the _version_ for version tracking commits to solr.
        """
        met = self.get_prod_met(product_id)
        met['CAS.ProductTransferStatus'] = 'FAILED'
        return self.get_prod_met(met['id'])

    def add_prod_met(self, product_id, prod_met):
        """Add the product based metadata to solr.

        Returns
        -------
        met: dict : metadata containing the _version_ for version tracking commits to solr.
        """
        met = self.get_prod_met(product_id)
        #ProductName is mapped internally by OODT. Pop it if we're going to insert directly into SOLR.
        prod_met.pop('ProductName', None)
        met.update(prod_met)
        self._solr_add(met)
        return self.get_prod_met(met['id'])

    def get_prod_met(self, prod_id):
        """Get the metadata for a product, if prod_id is not specified, use self.prod_id.

        Parameters
        ----------
        prod_id: string : the product id to find.

        Returns
        -------
        met: dict : metadata containing the _version_ for version tracking commits to solr.
        """
        copy_fields = ['Observer_lowercase']
        query = 'id:{}'.format(prod_id)
        res = self._solr_search(query)
        if res.hits == 0 or res.hits >1:
            raise MetaDataHandlerException('{} returned for {}'.format(res.hits, query))
        #filter out copy field
        doc = res.docs[0]
        for c in copy_fields:
            doc.pop(c, None)
        return doc

    def prod_met_exists(self, prod_id):
        try:
            self.get_prod_met(prod_id)
            return True  
        except MetaDataHandlerException:
           return False
 
    def del_prod_met(self, prod_id):
        """Delete product metadata. Use with caution, as will delete product metadata
        from solr.

        Parameters
        ----------
        prod_id: string : the product id to delete.
        """
        # make sure product exists
        met = self.get_prod_met(prod_id)
        self._solr_delete(met['id'])
        return True

